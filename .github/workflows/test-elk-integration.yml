name: Test ELK Integration

on:
  push:
    branches: [ "*" ]
  pull_request:
    branches: [ "*" ]

jobs:
  test-elk-integration:
    runs-on: ubuntu-latest
    
    steps:
    - name: Checkout repository
      uses: actions/checkout@v4
    
    - name: Debug - List repository contents
      run: |
        echo "Current directory: $(pwd)"
        echo "Repository contents:"
        ls -la
        echo ""
        echo "Checking for elk directory:"
        if [ -d "elk" ]; then
          echo "elk directory exists"
          ls -la elk/
        else
          echo "ERROR: elk directory not found!"
          echo "Creating elk directory structure for testing..."
          mkdir -p elk
        fi
    
    - name: Set up JDK 17
      uses: actions/setup-java@v4
      with:
        java-version: '17'
        distribution: 'temurin'
    
    - name: Configure Docker and system limits
      run: |
        # Increase virtual memory for Elasticsearch
        sudo sysctl -w vm.max_map_count=262144
        
        # Show Docker info
        docker info
        
        # Show available resources
        echo "=== System resources ==="
        free -h
        df -h
    
    - name: Download Moderne CLI
      run: |
        # Download the latest Moderne CLI JAR (version >= 3.45.0)
        MOD_VERSION="3.45.5"
        curl -L -o mod.jar "https://repo1.maven.org/maven2/io/moderne/moderne-cli/${MOD_VERSION}/moderne-cli-${MOD_VERSION}.jar"
        # Make the JAR accessible from anywhere
        export MOD_JAR="$PWD/mod.jar"
        echo "MOD_JAR=$MOD_JAR" >> $GITHUB_ENV
        echo "Downloaded Moderne CLI to: $MOD_JAR"
        ls -la mod.jar
    
    - name: Verify Moderne CLI version
      run: |
        echo "MOD_JAR is set to: $MOD_JAR"
        java -jar "$MOD_JAR" --version
    
    - name: Start ELK Stack
      working-directory: ./elk
      run: |
        # Start only Elasticsearch first
        docker compose up -d elasticsearch
        echo "Waiting for Elasticsearch to be ready..."
        
        # Wait for Elasticsearch to be healthy with more detailed logging
        for i in {1..60}; do
          if curl -s http://localhost:9200/_cluster/health 2>/dev/null | grep -q '"status":"green"\|"status":"yellow"'; then
            echo "Elasticsearch is ready (attempt $i)"
            curl -s http://localhost:9200/_cluster/health | jq .
            break
          else
            echo "Waiting for Elasticsearch... (attempt $i/60)"
            if [ $i -eq 60 ]; then
              echo "ERROR: Elasticsearch failed to start"
              docker compose logs elasticsearch
              exit 1
            fi
            sleep 3
          fi
        done
        
        # Now start the rest of the services
        docker compose up -d
        
        # Wait for services to initialize
        sleep 10
        
        # Wait for Logstash to be ready (HTTP input on port 8080)
        echo "Waiting for Logstash HTTP input..."
        for i in {1..30}; do
          HTTP_CODE=$(curl -s -o /dev/null -w "%{http_code}" http://localhost:8080 2>/dev/null || echo "000")
          if [[ "$HTTP_CODE" == "400" || "$HTTP_CODE" == "405" ]]; then
            echo "Logstash HTTP input is ready (attempt $i)"
            break
          else
            echo "Waiting for Logstash... (attempt $i/30, HTTP code: $HTTP_CODE)"
            if [ $i -eq 30 ]; then
              echo "WARNING: Logstash HTTP input may not be ready"
              docker compose logs logstash
            fi
            sleep 2
          fi
        done
        
        # Wait for Kibana to be ready (optional, not critical for tests)
        echo "Waiting for Kibana..."
        for i in {1..30}; do
          if curl -s http://localhost:5601/api/status 2>/dev/null | grep -q "available"; then
            echo "Kibana is ready (attempt $i)"
            break
          else
            echo "Waiting for Kibana... (attempt $i/30)"
            if [ $i -eq 30 ]; then
              echo "WARNING: Kibana may not be ready (not critical for tests)"
            fi
            sleep 2
          fi
        done
        
        # Show service status
        echo "=== Final service status ==="
        docker compose ps
        
        # Show that Elasticsearch is responding
        echo "=== Elasticsearch cluster health ==="
        curl -s http://localhost:9200/_cluster/health | jq . || true
    
    - name: Create test project for build
      run: |
        # Create a simple Java project for testing
        mkdir -p test-project/src/main/java/com/example
        cat > test-project/src/main/java/com/example/HelloWorld.java << 'EOF'
        package com.example;
        
        public class HelloWorld {
            public static void main(String[] args) {
                System.out.println("Hello, World!");
            }
        }
        EOF
        
        # Create a simple pom.xml
        cat > test-project/pom.xml << 'EOF'
        <?xml version="1.0" encoding="UTF-8"?>
        <project xmlns="http://maven.apache.org/POM/4.0.0"
                 xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
                 xsi:schemaLocation="http://maven.apache.org/POM/4.0.0
                 http://maven.apache.org/xsd/maven-4.0.0.xsd">
            <modelVersion>4.0.0</modelVersion>
            
            <groupId>com.example</groupId>
            <artifactId>test-project</artifactId>
            <version>1.0.0</version>
            
            <properties>
                <maven.compiler.source>17</maven.compiler.source>
                <maven.compiler.target>17</maven.compiler.target>
                <project.build.sourceEncoding>UTF-8</project.build.sourceEncoding>
            </properties>
        </project>
        EOF
    
    - name: Test mod.sh build command
      run: |
        # Make mod.sh executable
        chmod +x mod.sh
        
        # Debug: Show current location and MOD_JAR
        echo "Current directory: $PWD"
        echo "MOD_JAR is: $MOD_JAR"
        echo "mod.sh location: $PWD/mod.sh"
        
        # Run build command with ELK endpoint
        cd test-project
        echo "Now in: $PWD"
        echo "Using MOD_JAR: $MOD_JAR"
        
        BI_ENDPOINT="http://localhost:8080" \
        MOD_JAR="$MOD_JAR" \
        ../mod.sh build .
        
        # Check that the command succeeded
        if [ $? -ne 0 ]; then
          echo "mod.sh build command failed!"
          exit 1
        fi
        
        echo "mod.sh build command completed successfully"
    
    - name: Test mod.sh run command
      run: |
        cd test-project
        
        # Run a simple recipe with ELK endpoint
        BI_ENDPOINT="http://localhost:8080" \
        MOD_JAR="$MOD_JAR" \
        ../mod.sh run . --recipe org.openrewrite.java.format.AutoFormat
        
        # Check that the command succeeded
        if [ $? -ne 0 ]; then
          echo "mod.sh run command failed!"
          exit 1
        fi
        
        echo "mod.sh run command completed successfully"
    
    - name: Verify telemetry was sent to ELK
      run: |
        # Wait a moment for data to be indexed
        sleep 5
        
        # Check if any indices were created in Elasticsearch
        echo "Checking Elasticsearch indices..."
        curl -s http://localhost:9200/_cat/indices?v
        
        # Check for build metrics index
        if curl -s http://localhost:9200/_cat/indices | grep -q "build-metrics"; then
          echo "Build metrics index found in Elasticsearch"
        else
          echo "Warning: Build metrics index not found (may be expected with --dry-run)"
        fi
        
        # Check for run metrics index
        if curl -s http://localhost:9200/_cat/indices | grep -q "run-metrics"; then
          echo "Run metrics index found in Elasticsearch"
        else
          echo "Warning: Run metrics index not found (may be expected with --dry-run)"
        fi
    
    - name: Test with authentication and proxy
      run: |
        cd test-project
        
        # Test with authentication parameters (should still work even if not actually used by endpoint)
        BI_ENDPOINT="http://localhost:8080" \
        BI_AUTH_USER="testuser" \
        BI_AUTH_PASS="testpass" \
        MOD_JAR="$MOD_JAR" \
        ../mod.sh build .
        
        if [ $? -ne 0 ]; then
          echo "mod.sh build with auth parameters failed!"
          exit 1
        fi
        
        # Test with proxy parameters (proxy won't actually be used since localhost)
        BI_ENDPOINT="http://localhost:8080" \
        HTTP_PROXY="http://proxy.example.com:3128" \
        PROXY_USER="proxyuser" \
        PROXY_PASS="proxypass" \
        MOD_JAR="$MOD_JAR" \
        ../mod.sh run . --recipe org.openrewrite.java.format.AutoFormat
        
        if [ $? -ne 0 ]; then
          echo "mod.sh run with proxy parameters failed!"
          exit 1
        fi
        
        echo "All authentication and proxy parameter tests passed"
    
    - name: Show logs on failure
      if: failure()
      run: |
        echo "=== Docker Compose Status ==="
        cd elk && docker compose ps
        
        echo "=== Elasticsearch Logs ==="
        cd elk && docker compose logs --tail=50 elasticsearch
        
        echo "=== Logstash Logs ==="
        cd elk && docker compose logs --tail=50 logstash
        
        echo "=== Kibana Logs ==="
        cd elk && docker compose logs --tail=50 kibana
        
        echo "=== Init Logs ==="
        cd elk && docker compose logs init
    
    - name: Stop ELK Stack
      if: always()
      working-directory: ./elk
      run: |
        docker compose down -v