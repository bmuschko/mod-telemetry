name: Test ELK Integration

on:
  push:
    branches: [ "*" ]
  pull_request:
    branches: [ "*" ]

jobs:
  test-elk-integration:
    runs-on: ubuntu-latest
    
    steps:
    - name: Checkout repository
      uses: actions/checkout@v4
    
    - name: Debug - List repository contents
      run: |
        echo "Current directory: $(pwd)"
        echo "Repository contents:"
        ls -la
        echo ""
        echo "Checking for elk directory:"
        if [ -d "elk" ]; then
          echo "elk directory exists"
          ls -la elk/
        else
          echo "ERROR: elk directory not found!"
          echo "Creating elk directory structure for testing..."
          mkdir -p elk
        fi
    
    - name: Set up JDK 17
      uses: actions/setup-java@v4
      with:
        java-version: '17'
        distribution: 'temurin'
    
    - name: Configure Docker and system limits
      run: |
        # Increase virtual memory for Elasticsearch
        sudo sysctl -w vm.max_map_count=262144
        
        # Show Docker info
        docker info
        
        # Show available resources
        echo "=== System resources ==="
        free -h
        df -h
    
    - name: Download Moderne CLI
      run: |
        # Download the latest Moderne CLI JAR (version >= 3.45.0)
        MOD_VERSION="3.45.5"
        curl -L -o mod.jar "https://repo1.maven.org/maven2/io/moderne/moderne-cli/${MOD_VERSION}/moderne-cli-${MOD_VERSION}.jar"
        # Make the JAR accessible from anywhere
        export MOD_JAR="$PWD/mod.jar"
        echo "MOD_JAR=$MOD_JAR" >> $GITHUB_ENV
        echo "Downloaded Moderne CLI to: $MOD_JAR"
        ls -la mod.jar
    
    - name: Verify Moderne CLI version
      run: |
        echo "MOD_JAR is set to: $MOD_JAR"
        java -jar "$MOD_JAR" --version
    
    - name: Start ELK Stack
      working-directory: ./elk
      run: |
        # Start only Elasticsearch first
        docker compose up -d elasticsearch
        echo "Waiting for Elasticsearch to be ready..."
        
        # Wait for Elasticsearch to be healthy with more detailed logging
        for i in {1..60}; do
          if curl -s http://localhost:9200/_cluster/health 2>/dev/null | grep -q '"status":"green"\|"status":"yellow"'; then
            echo "Elasticsearch is ready (attempt $i)"
            curl -s http://localhost:9200/_cluster/health | jq .
            break
          else
            echo "Waiting for Elasticsearch... (attempt $i/60)"
            if [ $i -eq 60 ]; then
              echo "ERROR: Elasticsearch failed to start"
              docker compose logs elasticsearch
              exit 1
            fi
            sleep 3
          fi
        done
        
        # Now start the rest of the services
        docker compose up -d
        
        # Wait for services to initialize
        sleep 10
        
        # Wait for Logstash to be ready (HTTP input on port 8080)
        echo "Waiting for Logstash HTTP input..."
        for i in {1..30}; do
          HTTP_CODE=$(curl -s -o /dev/null -w "%{http_code}" http://localhost:8080 2>/dev/null || echo "000")
          if [[ "$HTTP_CODE" == "400" || "$HTTP_CODE" == "405" ]]; then
            echo "Logstash HTTP input is ready (attempt $i)"
            break
          else
            echo "Waiting for Logstash... (attempt $i/30, HTTP code: $HTTP_CODE)"
            if [ $i -eq 30 ]; then
              echo "WARNING: Logstash HTTP input may not be ready"
              docker compose logs logstash
            fi
            sleep 2
          fi
        done
        
        # Wait for Kibana to be ready (optional, not critical for tests)
        echo "Waiting for Kibana..."
        for i in {1..30}; do
          if curl -s http://localhost:5601/api/status 2>/dev/null | grep -q "available"; then
            echo "Kibana is ready (attempt $i)"
            break
          else
            echo "Waiting for Kibana... (attempt $i/30)"
            if [ $i -eq 30 ]; then
              echo "WARNING: Kibana may not be ready (not critical for tests)"
            fi
            sleep 2
          fi
        done
        
        # Show service status
        echo "=== Final service status ==="
        docker compose ps
        
        # Show that Elasticsearch is responding
        echo "=== Elasticsearch cluster health ==="
        curl -s http://localhost:9200/_cluster/health | jq . || true
    
    - name: Clone test repository
      run: |
        # Clone an actual open source repository for testing
        git clone https://github.com/bmuschko/httpclient5.git test-project
        cd test-project
        
        echo "Cloned repository structure:"
        ls -la
        git status
        git remote -v
    
    - name: Test mod.sh build command
      run: |
        # Make mod.sh executable
        chmod +x mod.sh
        
        # Debug: Show current location and MOD_JAR
        echo "Current directory: $PWD"
        echo "MOD_JAR is: $MOD_JAR"
        echo "mod.sh location: $PWD/mod.sh"
        
        # Run build command with ELK endpoint
        cd test-project
        echo "Now in: $PWD"
        echo "Using MOD_JAR: $MOD_JAR"
        
        # Run the build command and capture exit code
        BI_ENDPOINT="http://localhost:8080" \
        MOD_JAR="$MOD_JAR" \
        ../mod.sh build . 2>&1 | tee build_output.txt
        BUILD_EXIT_CODE=${PIPESTATUS[0]}
        
        # Check that the command succeeded
        if [ $BUILD_EXIT_CODE -ne 0 ]; then
          echo "mod.sh build command failed with exit code $BUILD_EXIT_CODE"
          exit 1
        fi
        
        # Verify that 1 repository was built
        if grep -q "Built 1 repository\." build_output.txt; then
          echo "✓ Successfully built 1 repository"
        else
          echo "ERROR: Expected to build 1 repository"
          exit 1
        fi
        
        echo "mod.sh build command completed successfully"
    
    - name: Install recipe and test mod.sh run command
      run: |
        cd test-project
        
        # Install the OpenRewrite recipe
        echo "Installing OpenRewrite recipes..."
        java -jar "$MOD_JAR" config recipes jar install org.openrewrite:rewrite-java:LATEST
        
        # Now run a simple recipe with ELK endpoint
        echo "Running recipe with telemetry..."
        BI_ENDPOINT="http://localhost:8080" \
        MOD_JAR="$MOD_JAR" \
        ../mod.sh run . --recipe org.openrewrite.java.format.AutoFormat 2>&1 | tee run_output.txt
        RUN_EXIT_CODE=${PIPESTATUS[0]}
        
        # Check that the command succeeded
        if [ $RUN_EXIT_CODE -ne 0 ]; then
          echo "mod.sh run command failed with exit code $RUN_EXIT_CODE"
          exit 1
        fi
        
        # Verify that results were produced for 1 repository
        if grep -q "Produced results for 1 repository\." run_output.txt; then
          echo "✓ Successfully produced results for 1 repository"
        else
          echo "ERROR: Expected to produce results for 1 repository"
          exit 1
        fi
        
        echo "mod.sh run command completed successfully"
    
    - name: Verify telemetry was sent to ELK
      run: |
        # Wait a moment for data to be indexed
        sleep 10
        
        # Check if any indices were created in Elasticsearch
        echo "Checking Elasticsearch indices..."
        curl -s http://localhost:9200/_cat/indices?v
        
        # Check for build metrics index
        if curl -s http://localhost:9200/_cat/indices | grep -q "build-metrics"; then
          echo "✓ Build metrics index found in Elasticsearch"
        else
          echo "Note: Build metrics index not found yet (telemetry may still be processing)"
        fi
        
        # Check for run metrics index
        if curl -s http://localhost:9200/_cat/indices | grep -q "run-metrics"; then
          echo "✓ Run metrics index found in Elasticsearch"
        else
          echo "Note: Run metrics index not found yet (telemetry may still be processing)"
        fi
        
        # Show count of documents if indices exist
        echo ""
        echo "Document counts:"
        BUILD_COUNT=$(curl -s "http://localhost:9200/build-metrics-*/_count" 2>/dev/null | jq -r '.count // 0')
        RUN_COUNT=$(curl -s "http://localhost:9200/run-metrics-*/_count" 2>/dev/null | jq -r '.count // 0')
        
        echo "Build metrics documents: $BUILD_COUNT"
        echo "Run metrics documents: $RUN_COUNT"
        
        # Verify exactly 1 document was indexed for each type
        if [ "$BUILD_COUNT" -eq 1 ]; then
          echo "✓ Build metrics successfully indexed (1 document)"
        else
          echo "ERROR: Expected 1 build metrics document, but found $BUILD_COUNT"
          exit 1
        fi
        
        if [ "$RUN_COUNT" -eq 1 ]; then
          echo "✓ Run metrics successfully indexed (1 document)"
        else
          echo "ERROR: Expected 1 run metrics document, but found $RUN_COUNT"
          exit 1
        fi
    
    - name: Show logs on failure
      if: failure()
      run: |
        echo "=== Docker Compose Status ==="
        cd elk && docker compose ps
        
        echo "=== Elasticsearch Logs ==="
        cd elk && docker compose logs --tail=50 elasticsearch
        
        echo "=== Logstash Logs ==="
        cd elk && docker compose logs --tail=50 logstash
        
        echo "=== Kibana Logs ==="
        cd elk && docker compose logs --tail=50 kibana
        
        echo "=== Init Logs ==="
        cd elk && docker compose logs init
    
    - name: Stop ELK Stack
      if: always()
      working-directory: ./elk
      run: |
        docker compose down -v