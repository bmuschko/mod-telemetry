input {
  http {
    port => 8080
    codec => line
  }
}

filter {
  # Skip header line
  if [message] =~ /^origin,/ {
    drop { }
  }
  
  # Skip empty lines  
  if [message] =~ /^\s*$/ {
    drop { }
  }
  
  # Determine data type based on presence of specific fields in CSV
  # Build metrics have buildId, run metrics have runId
  ruby {
    code => '
      msg = event.get("message")
      if msg
        # Check for presence of buildId or runId in the CSV
        if msg.include?("build") && msg.split(",").length > 20
          event.set("data_type", "build")
        elsif msg.include?("run") && msg.split(",").length > 20
          event.set("data_type", "run")
        end
      end
    '
  }
  
  # Process build metrics
  if [data_type] == "build" {
    csv {
      separator => ","
      columns => [
        "origin", "path", "branch", "developer", "buildSuccess",
        "buildStartTime", "buildEndTime", "buildLog", "buildId", "buildChangeset",
        "buildDependencyResolutionTimeMs", "buildMavenVersion", "buildGradleVersion",
        "buildBazelVersion", "buildDotnetVersion", "buildPythonVersion", "buildNodeVersion",
        "buildSourceFileCount", "buildLineCount", "buildParseErrorCount",
        "buildWeight", "buildMaxWeight", "buildMaxWeightSourceFile", "buildElapsedTimeMs",
        "cloneSuccess", "cloneCloneUri", "cloneStartTime", "cloneEndTime",
        "cloneLog", "cloneChangeset", "cloneElapsedTimeMs", "organization"
      ]
    }
    
    if [buildId] {
      mutate {
        convert => {
          "buildSuccess" => "boolean"
          "cloneSuccess" => "boolean"
          "buildElapsedTimeMs" => "integer"
          "cloneElapsedTimeMs" => "integer"
          "buildDependencyResolutionTimeMs" => "integer"
          "buildSourceFileCount" => "integer"
          "buildLineCount" => "integer"
          "buildParseErrorCount" => "integer"
          "buildWeight" => "integer"
          "buildMaxWeight" => "integer"
        }
      }
      
      date {
        match => [ "buildStartTime", "ISO8601" ]
        target => "buildStartTimeParsed"
      }
      
      date {
        match => [ "buildEndTime", "ISO8601" ]
        target => "buildEndTimeParsed"
      }
      
      date {
        match => [ "cloneStartTime", "ISO8601" ]
        target => "cloneStartTimeParsed"
      }
      
      date {
        match => [ "cloneEndTime", "ISO8601" ]
        target => "cloneEndTimeParsed"
      }
      
      ruby {
        code => '
          # Calculate durations
          build_ms = event.get("buildElapsedTimeMs")
          if build_ms
            event.set("buildDurationSeconds", build_ms.to_f / 1000)
          end
          
          clone_ms = event.get("cloneElapsedTimeMs")
          if clone_ms
            event.set("cloneDurationSeconds", clone_ms.to_f / 1000)
          end
          
          # Set build status
          success = event.get("buildSuccess")
          if success == true
            event.set("buildStatus", "success")
          elsif success == false
            event.set("buildStatus", "failed")  
          else
            event.set("buildStatus", "unknown")
          end
          
          # Determine primary build tool
          if event.get("buildGradleVersion") && event.get("buildGradleVersion") != ""
            event.set("primaryBuildTool", "Gradle")
          elsif event.get("buildMavenVersion") && event.get("buildMavenVersion") != ""
            event.set("primaryBuildTool", "Maven")
          elsif event.get("buildBazelVersion") && event.get("buildBazelVersion") != ""
            event.set("primaryBuildTool", "Bazel")
          elsif event.get("buildDotnetVersion") && event.get("buildDotnetVersion") != ""
            event.set("primaryBuildTool", "Dotnet")
          elsif event.get("buildPythonVersion") && event.get("buildPythonVersion") != ""
            event.set("primaryBuildTool", "Python")
          elsif event.get("buildNodeVersion") && event.get("buildNodeVersion") != ""
            event.set("primaryBuildTool", "Node")
          else
            event.set("primaryBuildTool", "Unknown")
          end
          
          # Extract repository info from path
          path = event.get("path")
          if path
            parts = path.split("/")
            if parts.length >= 2
              event.set("repositoryOwner", parts[-2])
              event.set("repositoryName", parts[-1])
            end
          end
        '
      }
      
      mutate {
        add_field => { "processed_at" => "%{@timestamp}" }
      }
    }
  }
  
  # Process run metrics
  if [data_type] == "run" {
    csv {
      separator => ","
      columns => [
        "origin", "path", "branch", "developer", "runSuccess",
        "runStartTime", "runEndTime", "runId", "runChangeset",
        "runMavenVersion", "runGradleVersion", "runBazelVersion",
        "runDotnetVersion", "runPythonVersion", "runNodeVersion",
        "runRecipe", "runRecipesChanged",
        "runSourceFileCount", "runVisitedSourceFileCount",
        "runLineCount", "runVisitedLineCount",
        "runRecipeRunElapsedTimeMs", "runElapsedTimeMs", "organization"
      ]
    }
    
    if [runId] {
      mutate {
        convert => {
          "runSuccess" => "boolean"
          "runElapsedTimeMs" => "integer"
          "runRecipeRunElapsedTimeMs" => "integer"
          "runSourceFileCount" => "integer"
          "runVisitedSourceFileCount" => "integer"
          "runLineCount" => "integer"
          "runVisitedLineCount" => "integer"
        }
      }
      
      date {
        match => [ "runStartTime", "ISO8601" ]
        target => "runStartTimeParsed"
      }
      
      date {
        match => [ "runEndTime", "ISO8601" ]
        target => "runEndTimeParsed"
      }
      
      ruby {
        code => '
          # Calculate durations
          run_ms = event.get("runElapsedTimeMs")
          if run_ms
            event.set("runDurationSeconds", run_ms.to_f / 1000)
          end
          
          recipe_ms = event.get("runRecipeRunElapsedTimeMs")
          if recipe_ms
            event.set("recipeRunDurationSeconds", recipe_ms.to_f / 1000)
          end
          
          # Set run status
          success = event.get("runSuccess")
          if success == true
            event.set("runStatus", "success")
          elsif success == false
            event.set("runStatus", "failed")  
          else
            event.set("runStatus", "unknown")
          end
          
          # Calculate visitation percentages
          source_count = event.get("runSourceFileCount")
          visited_count = event.get("runVisitedSourceFileCount")
          if source_count && visited_count && source_count > 0
            event.set("fileVisitationPercentage", (visited_count.to_f / source_count.to_f) * 100)
          end
          
          line_count = event.get("runLineCount")
          visited_lines = event.get("runVisitedLineCount")
          if line_count && visited_lines && line_count > 0
            event.set("lineVisitationPercentage", (visited_lines.to_f / line_count.to_f) * 100)
          end
          
          # Determine build tool
          if event.get("runGradleVersion") && event.get("runGradleVersion") != ""
            event.set("primaryBuildTool", "Gradle")
          elsif event.get("runMavenVersion") && event.get("runMavenVersion") != ""
            event.set("primaryBuildTool", "Maven")
          else
            event.set("primaryBuildTool", "Unknown")
          end
          
          # Parse recipes changed
          recipes_changed = event.get("runRecipesChanged")
          if recipes_changed && recipes_changed != ""
            recipes_array = recipes_changed.split(";")
            event.set("recipesChangedCount", recipes_array.length)
            event.set("recipesChangedList", recipes_array)
          else
            event.set("recipesChangedCount", 0)
          end
          
          # Extract repository info
          path = event.get("path")
          if path
            parts = path.split("/")
            if parts.length >= 2
              event.set("repositoryOwner", parts[-2])
              event.set("repositoryName", parts[-1])
            end
          end
        '
      }
      
      mutate {
        add_field => { "processed_at" => "%{@timestamp}" }
      }
    }
  }
  
  # Clean up common fields
  mutate {
    remove_field => ["message", "host", "@version"]
  }
}

output {
  stdout { codec => rubydebug }
  
  # Route to appropriate index based on data type
  if [buildId] {
    elasticsearch {
      hosts => ["elasticsearch:9200"]
      index => "build-metrics-%{+YYYY.MM.dd}"
      document_id => "%{buildId}"
    }
  }
  
  if [runId] {
    elasticsearch {
      hosts => ["elasticsearch:9200"]
      index => "run-metrics-%{+YYYY.MM.dd}"
      document_id => "%{runId}"
    }
  }
}