input {
  http {
    port => 8080
    codec => line {
      charset => "UTF-8"
    }
  }
}

filter {
  # Handle both message formats
  if ![message] and [event][original] {
    mutate {
      add_field => { "message" => "%{[event][original]}" }
    }
  }
  
  # Skip header line
  if [message] =~ /^origin,/ {
    drop { }
  }
  
  # Skip empty lines
  if [message] =~ /^\s*$/ {
    drop { }
  }
  
  # Count fields to determine format
  ruby {
    code => '
      msg = event.get("message") || event.get("[event][original]")
      if msg
        fields = msg.split(",")
        field_count = fields.length
        event.set("field_count", field_count)
        
        # Determine type based purely on field count and structure
        # No hard-coded values, just structural patterns
        
        if field_count == 24
          # Could be either build or run v1 format
          # Check field 10-11 for distinguishing patterns
          if fields.length > 11
            field_10 = fields[10] || ""
            field_11 = fields[11] || ""
            
            # If field 10/11 contains dots (like package names), likely run data
            # If field 10/11 is empty or contains version-like patterns, likely build data
            if field_10.include?(".") && field_10 =~ /[a-zA-Z]/
              event.set("data_type", "run_v1")
            else
              event.set("data_type", "build_v1")
            end
          else
            event.set("data_type", "build_v1")
          end
        elsif field_count == 32
          event.set("data_type", "build_v2")
        elsif field_count >= 40
          event.set("data_type", "run_v2")
        else
          event.set("data_type", "unknown")
        end
      end
    '
  }
  
  # Process run metrics v2 format (42+ fields)
  if [data_type] == "run_v2" {
    csv {
      separator => ","
      skip_header => false
      quote_char => "\x00"  # Disable quote processing to handle embedded JSON
      columns => [
        "origin", "repository", "branch", "developer", "runSuccess",
        "runStartTime", "runEndTime", "runId", "field9", "field10",
        "runRecipe", "runDescription", "field13", "runRecipeCoordinates",
        "field15", "field16", "field17", "field18", "field19",
        "field20", "field21", "runElapsedTimeMs", "field23",
        "buildStartTime", "buildEndTime", "buildId", "buildChangeset",
        "buildElapsedTimeMs", "field29", "buildGradleVersion",
        "field31", "field32", "field33", "field34",
        "buildSourceFileCount", "buildLineCount", "buildParseErrorCount",
        "field38", "field39", "buildTool", "field41", "organization"
      ]
    }
    
    mutate {
      convert => {
        "runElapsedTimeMs" => "integer"
        "buildSourceFileCount" => "integer"
        "buildLineCount" => "integer"
      }
    }
    
    date {
      match => [ "runStartTime", "ISO8601" ]
      target => "runStartTimeParsed"
    }
    
    date {
      match => [ "runEndTime", "ISO8601" ]
      target => "runEndTimeParsed"
    }
    
    ruby {
      code => '
        # Calculate duration
        run_ms = event.get("runElapsedTimeMs")
        if run_ms && run_ms.to_i > 0
          event.set("runDurationSeconds", run_ms.to_f / 1000.0)
        end
        
        # Set status
        success = event.get("runSuccess")
        if success == "true"
          event.set("runStatus", "success")
        else
          event.set("runStatus", "failed")
        end
        
        # Extract recipe short name
        recipe = event.get("runRecipe")
        if recipe
          parts = recipe.split(".")
          event.set("runRecipeShort", parts[-1])
        end
        
        # Set build tool
        gradle = event.get("buildGradleVersion")
        tool = event.get("buildTool")
        if gradle && gradle != ""
          event.set("primaryBuildTool", "Gradle")
        elsif tool && tool != ""
          event.set("primaryBuildTool", tool)
        else
          event.set("primaryBuildTool", "Unknown")
        end
        
        # Extract repository info
        repo = event.get("repository")
        if repo
          parts = repo.split("/")
          if parts.length >= 2
            event.set("repositoryOwner", parts[0])
            event.set("repositoryName", parts[1])
          end
        end
        
        # Set compatibility fields
        event.set("runSourceFileCount", event.get("buildSourceFileCount") || 0)
        event.set("runLineCount", event.get("buildLineCount") || 0)
        event.set("fileVisitationPercentage", 100.0)
        event.set("lineVisitationPercentage", 100.0)
        event.set("recipesChangedCount", 1)
      '
    }
  }
  
  # Process build metrics v1 format (24 fields) 
  if [data_type] == "build_v1" {
    csv {
      separator => ","
      skip_header => false
      quote_char => "\x00"  # Disable quote processing
      columns => [
        "origin", "repository", "branch", "developer", "buildSuccess",
        "buildStartTime", "buildEndTime", "buildId", "buildChangeset",
        "buildDependencyResolutionTimeMs", "field11", "buildGradleVersion",
        "field13", "field14", "field15", "field16",
        "buildSourceFileCount", "buildLineCount", "buildParseErrorCount",
        "field20", "field21", "buildTool", "buildElapsedTimeMs", "organization"
      ]
    }
    
    mutate {
      convert => {
        "buildElapsedTimeMs" => "integer"
        "buildSourceFileCount" => "integer"
        "buildLineCount" => "integer"
        "buildParseErrorCount" => "integer"
        "buildDependencyResolutionTimeMs" => "integer"
      }
    }
    
    date {
      match => [ "buildStartTime", "ISO8601" ]
      target => "buildStartTimeParsed"
    }
    
    date {
      match => [ "buildEndTime", "ISO8601" ]
      target => "buildEndTimeParsed"
    }
    
    ruby {
      code => '
        # Calculate duration
        build_ms = event.get("buildElapsedTimeMs")
        if build_ms && build_ms.to_i > 0
          event.set("buildDurationSeconds", build_ms.to_f / 1000.0)
        end
        
        # Set status
        success = event.get("buildSuccess")
        if success == "true"
          event.set("buildStatus", "success")
        else
          event.set("buildStatus", "failed")
        end
        
        # Determine build tool
        gradle = event.get("buildGradleVersion")
        tool = event.get("buildTool")
        if gradle && gradle != ""
          event.set("primaryBuildTool", "Gradle")
        elsif tool && tool != ""
          event.set("primaryBuildTool", tool)
        else
          event.set("primaryBuildTool", "Unknown")
        end
        
        # Extract repository info
        repo = event.get("repository")
        if repo
          parts = repo.split("/")
          if parts.length >= 2
            event.set("repositoryOwner", parts[0])
            event.set("repositoryName", parts[1])
          end
        end
      '
    }
  }
  
  # Process build metrics v2 format (32 fields)
  if [data_type] == "build_v2" {
    csv {
      separator => ","
      skip_header => false
      quote_char => "\x00"  # Disable quote processing
      columns => [
        "origin", "path", "branch", "developer", "buildSuccess",
        "buildStartTime", "buildEndTime", "buildLog", "buildId", "buildChangeset",
        "buildDependencyResolutionTimeMs", "buildMavenVersion", "buildGradleVersion",
        "buildBazelVersion", "buildDotnetVersion", "buildPythonVersion", "buildNodeVersion",
        "buildSourceFileCount", "buildLineCount", "buildParseErrorCount",
        "buildWeight", "buildMaxWeight", "buildMaxWeightSourceFile", "buildElapsedTimeMs",
        "cloneSuccess", "cloneCloneUri", "cloneStartTime", "cloneEndTime",
        "cloneLog", "cloneChangeset", "cloneElapsedTimeMs", "organization"
      ]
    }
    
    mutate {
      convert => {
        "buildElapsedTimeMs" => "integer"
        "buildSourceFileCount" => "integer"
        "buildLineCount" => "integer"
        "buildParseErrorCount" => "integer"
      }
    }
    
    date {
      match => [ "buildStartTime", "ISO8601" ]
      target => "buildStartTimeParsed"
    }
    
    ruby {
      code => '
        # Calculate duration
        build_ms = event.get("buildElapsedTimeMs")
        if build_ms && build_ms.to_i > 0
          event.set("buildDurationSeconds", build_ms.to_f / 1000.0)
        end
        
        # Set status
        success = event.get("buildSuccess")
        if success == "true"
          event.set("buildStatus", "success")
        else
          event.set("buildStatus", "failed")
        end
        
        # Determine build tool
        if event.get("buildGradleVersion") && event.get("buildGradleVersion") != ""
          event.set("primaryBuildTool", "Gradle")
        elsif event.get("buildMavenVersion") && event.get("buildMavenVersion") != ""
          event.set("primaryBuildTool", "Maven")
        else
          event.set("primaryBuildTool", "Unknown")
        end
        
        # Extract repository info
        path = event.get("path")
        if path
          parts = path.split("/")
          if parts.length >= 2
            event.set("repositoryOwner", parts[-2])
            event.set("repositoryName", parts[-1])
          end
        end
      '
    }
  }
  
  # Add timestamp and clean up
  mutate {
    add_field => { "processed_at" => "%{@timestamp}" }
    remove_field => ["message", "host", "@version", "field9", "field10", "field13", "field15", "field16", "field17", "field18", "field19", "field20", "field21", "field23", "field29", "field31", "field32", "field33", "field34", "field38", "field39", "field41"]
  }
}

output {
  # Debug output
  stdout { 
    codec => rubydebug {
      metadata => false
    }
  }
  
  # Index build metrics
  if [buildId] and ([data_type] == "build_v2" or [data_type] == "build_v1") {
    elasticsearch {
      hosts => ["elasticsearch:9200"]
      index => "build-metrics-%{+YYYY.MM.dd}"
      document_id => "%{buildId}"
    }
  }
  
  # Index run metrics
  if [runId] and ([data_type] == "run_v1" or [data_type] == "run_v2") {
    elasticsearch {
      hosts => ["elasticsearch:9200"]
      index => "run-metrics-%{+YYYY.MM.dd}"
      document_id => "%{runId}"
    }
  }
}