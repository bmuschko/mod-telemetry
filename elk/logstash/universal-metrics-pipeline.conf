input {
  http {
    port => 8080
    codec => line
  }
}

filter {
  # Get the actual message from the event
  mutate {
    add_field => { "message" => "%{[event][original]}" }
  }
  
  # Skip header line
  if [message] =~ /^origin,/ {
    drop { }
  }
  
  # Skip empty lines  
  if [message] =~ /^\s*$/ {
    drop { }
  }
  
  # Detect data type by counting fields and checking content
  ruby {
    code => '
      msg = event.get("message") || event.get("[event][original]")
      if msg
        fields = msg.split(",")
        field_count = fields.length
        
        # Check for recipe patterns that indicate run data
        has_recipe = msg.include?("org.openrewrite") || msg.include?("DependencyVulnerability")
        
        if field_count >= 40 && has_recipe
          # This is the actual run telemetry format with 42 fields
          event.set("data_type", "run_v2")
        elsif field_count > 30 && !has_recipe
          # This is build telemetry (32 fields)
          event.set("data_type", "build")
        elsif field_count == 24
          # This is the expected run format from documentation
          event.set("data_type", "run_v1")
        else
          event.set("data_type", "unknown")
          event.set("field_count", field_count)
        end
      end
    '
  }
  
  # Process actual run metrics format (42 fields)
  if [data_type] == "run_v2" {
    csv {
      separator => ","
      columns => [
        "origin", "repository", "branch", "developer", "field5",
        "runStartTime", "runEndTime", "runId", "field9", "field10",
        "runRecipe", "runDescription", "field13", "runRecipeCoordinates",
        "field15", "field16", "field17", "field18", "field19",
        "field20", "field21", "runElapsedTimeMs", "field23",
        "buildStartTime", "buildEndTime", "buildId", "buildChangeset",
        "buildElapsedTimeMs", "field29", "buildGradleVersion",
        "field31", "field32", "field33", "field34",
        "buildSourceFileCount", "buildLineCount", "buildParseErrorCount",
        "field38", "field39", "buildTool", "field41", "organization"
      ]
    }
    
    if [runId] {
      mutate {
        convert => {
          "runElapsedTimeMs" => "integer"
          "buildElapsedTimeMs" => "integer"
          "buildSourceFileCount" => "integer"
          "buildLineCount" => "integer"
          "buildParseErrorCount" => "integer"
        }
      }
      
      # Parse dates
      date {
        match => [ "runStartTime", "ISO8601" ]
        target => "runStartTimeParsed"
      }
      
      date {
        match => [ "runEndTime", "ISO8601" ]
        target => "runEndTimeParsed"
      }
      
      ruby {
        code => '
          # Calculate run duration
          run_ms = event.get("runElapsedTimeMs")
          if run_ms
            event.set("runDurationSeconds", run_ms.to_f / 1000)
          end
          
          # Set run status (field5 appears to be success indicator)
          success = event.get("field5")
          if success == "true"
            event.set("runStatus", "success")
            event.set("runSuccess", true)
          else
            event.set("runStatus", "failed")
            event.set("runSuccess", false)
          end
          
          # Extract recipe name without package
          recipe = event.get("runRecipe")
          if recipe
            parts = recipe.split(".")
            event.set("runRecipeShort", parts[-1])
          end
          
          # Determine build tool
          gradle = event.get("buildGradleVersion")
          tool = event.get("buildTool")
          if gradle && gradle != ""
            event.set("primaryBuildTool", "Gradle")
          elsif tool && tool != ""
            event.set("primaryBuildTool", tool)
          else
            event.set("primaryBuildTool", "Unknown")
          end
          
          # Extract repository info
          repo = event.get("repository")
          if repo
            parts = repo.split("/")
            if parts.length >= 2
              event.set("repositoryOwner", parts[0])
              event.set("repositoryName", parts[1])
            end
          end
          
          # Set placeholder values for compatibility
          event.set("runSourceFileCount", event.get("buildSourceFileCount"))
          event.set("runLineCount", event.get("buildLineCount"))
          event.set("fileVisitationPercentage", 100.0)
          event.set("lineVisitationPercentage", 100.0)
          event.set("recipesChangedCount", 1)
        '
      }
      
      mutate {
        add_field => { 
          "processed_at" => "%{@timestamp}"
          "data_format" => "v2"
        }
        remove_field => ["field5", "field9", "field10", "field13", "field15", "field16", "field17", "field18", "field19", "field20", "field21", "field23", "field29", "field31", "field32", "field33", "field34", "field38", "field39", "field41"]
      }
    }
  }
  
  # Process expected run metrics format (24 fields)
  if [data_type] == "run_v1" {
    csv {
      separator => ","
      columns => [
        "origin", "path", "branch", "developer", "runSuccess",
        "runStartTime", "runEndTime", "runId", "runChangeset",
        "runMavenVersion", "runGradleVersion", "runBazelVersion",
        "runDotnetVersion", "runPythonVersion", "runNodeVersion",
        "runRecipe", "runRecipesChanged",
        "runSourceFileCount", "runVisitedSourceFileCount",
        "runLineCount", "runVisitedLineCount",
        "runRecipeRunElapsedTimeMs", "runElapsedTimeMs", "organization"
      ]
    }
    
    if [runId] {
      mutate {
        convert => {
          "runSuccess" => "boolean"
          "runElapsedTimeMs" => "integer"
          "runRecipeRunElapsedTimeMs" => "integer"
          "runSourceFileCount" => "integer"
          "runVisitedSourceFileCount" => "integer"
          "runLineCount" => "integer"
          "runVisitedLineCount" => "integer"
        }
      }
      
      date {
        match => [ "runStartTime", "ISO8601" ]
        target => "runStartTimeParsed"
      }
      
      date {
        match => [ "runEndTime", "ISO8601" ]
        target => "runEndTimeParsed"
      }
      
      ruby {
        code => '
          # Calculate durations
          run_ms = event.get("runElapsedTimeMs")
          if run_ms
            event.set("runDurationSeconds", run_ms.to_f / 1000)
          end
          
          recipe_ms = event.get("runRecipeRunElapsedTimeMs")
          if recipe_ms
            event.set("recipeRunDurationSeconds", recipe_ms.to_f / 1000)
          end
          
          # Set run status
          success = event.get("runSuccess")
          if success == true
            event.set("runStatus", "success")
          elsif success == false
            event.set("runStatus", "failed")  
          else
            event.set("runStatus", "unknown")
          end
          
          # Calculate visitation percentages
          source_count = event.get("runSourceFileCount")
          visited_count = event.get("runVisitedSourceFileCount")
          if source_count && visited_count && source_count > 0
            event.set("fileVisitationPercentage", (visited_count.to_f / source_count.to_f) * 100)
          end
          
          line_count = event.get("runLineCount")
          visited_lines = event.get("runVisitedLineCount")
          if line_count && visited_lines && line_count > 0
            event.set("lineVisitationPercentage", (visited_lines.to_f / line_count.to_f) * 100)
          end
          
          # Determine build tool
          if event.get("runGradleVersion") && event.get("runGradleVersion") != ""
            event.set("primaryBuildTool", "Gradle")
          elsif event.get("runMavenVersion") && event.get("runMavenVersion") != ""
            event.set("primaryBuildTool", "Maven")
          else
            event.set("primaryBuildTool", "Unknown")
          end
          
          # Parse recipes changed
          recipes_changed = event.get("runRecipesChanged")
          if recipes_changed && recipes_changed != ""
            recipes_array = recipes_changed.split(";")
            event.set("recipesChangedCount", recipes_array.length)
            event.set("recipesChangedList", recipes_array)
          else
            event.set("recipesChangedCount", 0)
          end
          
          # Extract repository info
          path = event.get("path")
          if path
            parts = path.split("/")
            if parts.length >= 2
              event.set("repositoryOwner", parts[-2])
              event.set("repositoryName", parts[-1])
            end
          end
        '
      }
      
      mutate {
        add_field => { 
          "processed_at" => "%{@timestamp}"
          "data_format" => "v1"
        }
      }
    }
  }
  
  # Process build metrics
  if [data_type] == "build" {
    csv {
      separator => ","
      columns => [
        "origin", "path", "branch", "developer", "buildSuccess",
        "buildStartTime", "buildEndTime", "buildLog", "buildId", "buildChangeset",
        "buildDependencyResolutionTimeMs", "buildMavenVersion", "buildGradleVersion",
        "buildBazelVersion", "buildDotnetVersion", "buildPythonVersion", "buildNodeVersion",
        "buildSourceFileCount", "buildLineCount", "buildParseErrorCount",
        "buildWeight", "buildMaxWeight", "buildMaxWeightSourceFile", "buildElapsedTimeMs",
        "cloneSuccess", "cloneCloneUri", "cloneStartTime", "cloneEndTime",
        "cloneLog", "cloneChangeset", "cloneElapsedTimeMs", "organization"
      ]
    }
    
    if [buildId] {
      mutate {
        convert => {
          "buildSuccess" => "boolean"
          "cloneSuccess" => "boolean"
          "buildElapsedTimeMs" => "integer"
          "cloneElapsedTimeMs" => "integer"
          "buildDependencyResolutionTimeMs" => "integer"
          "buildSourceFileCount" => "integer"
          "buildLineCount" => "integer"
          "buildParseErrorCount" => "integer"
          "buildWeight" => "integer"
          "buildMaxWeight" => "integer"
        }
      }
      
      date {
        match => [ "buildStartTime", "ISO8601" ]
        target => "buildStartTimeParsed"
      }
      
      date {
        match => [ "buildEndTime", "ISO8601" ]
        target => "buildEndTimeParsed"
      }
      
      date {
        match => [ "cloneStartTime", "ISO8601" ]
        target => "cloneStartTimeParsed"
      }
      
      date {
        match => [ "cloneEndTime", "ISO8601" ]
        target => "cloneEndTimeParsed"
      }
      
      ruby {
        code => '
          # Calculate durations
          build_ms = event.get("buildElapsedTimeMs")
          if build_ms
            event.set("buildDurationSeconds", build_ms.to_f / 1000)
          end
          
          clone_ms = event.get("cloneElapsedTimeMs")
          if clone_ms
            event.set("cloneDurationSeconds", clone_ms.to_f / 1000)
          end
          
          # Set build status
          success = event.get("buildSuccess")
          if success == true
            event.set("buildStatus", "success")
          elsif success == false
            event.set("buildStatus", "failed")  
          else
            event.set("buildStatus", "unknown")
          end
          
          # Determine primary build tool
          if event.get("buildGradleVersion") && event.get("buildGradleVersion") != ""
            event.set("primaryBuildTool", "Gradle")
          elsif event.get("buildMavenVersion") && event.get("buildMavenVersion") != ""
            event.set("primaryBuildTool", "Maven")
          elsif event.get("buildBazelVersion") && event.get("buildBazelVersion") != ""
            event.set("primaryBuildTool", "Bazel")
          elsif event.get("buildDotnetVersion") && event.get("buildDotnetVersion") != ""
            event.set("primaryBuildTool", "Dotnet")
          elsif event.get("buildPythonVersion") && event.get("buildPythonVersion") != ""
            event.set("primaryBuildTool", "Python")
          elsif event.get("buildNodeVersion") && event.get("buildNodeVersion") != ""
            event.set("primaryBuildTool", "Node")
          else
            event.set("primaryBuildTool", "Unknown")
          end
          
          # Extract repository info from path
          path = event.get("path")
          if path
            parts = path.split("/")
            if parts.length >= 2
              event.set("repositoryOwner", parts[-2])
              event.set("repositoryName", parts[-1])
            end
          end
        '
      }
      
      mutate {
        add_field => { "processed_at" => "%{@timestamp}" }
      }
    }
  }
  
  # Clean up common fields
  mutate {
    remove_field => ["message", "host", "@version"]
  }
}

output {
  stdout { codec => rubydebug }
  
  # Route to appropriate index based on data type
  if [buildId] {
    elasticsearch {
      hosts => ["elasticsearch:9200"]
      index => "build-metrics-%{+YYYY.MM.dd}"
      document_id => "%{buildId}"
    }
  }
  
  if [runId] {
    elasticsearch {
      hosts => ["elasticsearch:9200"]
      index => "run-metrics-%{+YYYY.MM.dd}"
      document_id => "%{runId}"
    }
  }
}