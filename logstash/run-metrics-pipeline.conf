input {
  http {
    port => 8081
    codec => plain
    response_code => 200
    additional_codecs => {
      "application/json" => "json"
    }
  }
}

filter {
  # Handle CSV data from HTTP or file input
  if [headers][content-type] =~ /text\/csv/ or [headers][content-type] =~ /text\/plain/ {
    csv {
      separator => ","
      columns => [
        "origin",
        "path",
        "branch",
        "developer",
        "runSuccess",
        "runStartTime",
        "runEndTime",
        "runLog",
        "runId",
        "runChangeset",
        "runMavenVersion",
        "runGradleVersion",
        "runBazelVersion",
        "runDotnetVersion",
        "runPythonVersion",
        "runNodeVersion",
        "runRecipe",
        "runRecipesChanged",
        "runSourceFileCount",
        "runVisitedSourceFileCount",
        "runLineCount",
        "runVisitedLineCount",
        "runRecipeRunElapsedTimeMs",
        "runElapsedTimeMs",
        "organization"
      ]
      skip_header => true
      skip_empty_columns => true
    }
    
    # Convert data types
    mutate {
      convert => {
        "runSuccess" => "boolean"
        "runSourceFileCount" => "integer"
        "runVisitedSourceFileCount" => "integer"
        "runLineCount" => "integer"
        "runVisitedLineCount" => "integer"
        "runRecipeRunElapsedTimeMs" => "integer"
        "runElapsedTimeMs" => "integer"
      }
    }
    
    # Parse timestamps
    date {
      match => [ "runStartTime", "ISO8601" ]
      target => "runStartTimeParsed"
    }
    
    date {
      match => [ "runEndTime", "ISO8601" ]
      target => "runEndTimeParsed"
    }
    
    # Calculate additional metrics and clean data
    ruby {
      code => '
        # Extract repository name from path
        path = event.get("path")
        if path
          repo_parts = path.split("/")
          if repo_parts.length >= 2
            event.set("repositoryOwner", repo_parts[-2])
            event.set("repositoryName", repo_parts[-1])
          end
        end
        
        # Calculate run duration in seconds
        run_ms = event.get("runElapsedTimeMs")
        if run_ms
          event.set("runDurationSeconds", run_ms.to_f / 1000)
        end
        
        # Calculate recipe run duration in seconds
        recipe_ms = event.get("runRecipeRunElapsedTimeMs")
        if recipe_ms
          event.set("recipeRunDurationSeconds", recipe_ms.to_f / 1000)
        end
        
        # Calculate file visitation percentage
        source_count = event.get("runSourceFileCount")
        visited_count = event.get("runVisitedSourceFileCount")
        if source_count && visited_count && source_count > 0
          event.set("fileVisitationPercentage", (visited_count.to_f / source_count.to_f) * 100)
        end
        
        # Calculate line visitation percentage
        line_count = event.get("runLineCount")
        visited_lines = event.get("runVisitedLineCount")
        if line_count && visited_lines && line_count > 0
          event.set("lineVisitationPercentage", (visited_lines.to_f / line_count.to_f) * 100)
        end
        
        # Determine primary build tool
        if event.get("runGradleVersion")
          event.set("primaryBuildTool", "Gradle")
        elsif event.get("runMavenVersion")
          event.set("primaryBuildTool", "Maven")
        elsif event.get("runBazelVersion")
          event.set("primaryBuildTool", "Bazel")
        elsif event.get("runNodeVersion")
          event.set("primaryBuildTool", "Node")
        elsif event.get("runPythonVersion")
          event.set("primaryBuildTool", "Python")
        elsif event.get("runDotnetVersion")
          event.set("primaryBuildTool", "Dotnet")
        end
        
        # Normalize organization (handle ε or empty)
        org = event.get("organization")
        if org == "ε" || org == "" || org.nil?
          event.set("organization", "Unknown")
        end
        
        # Set run status string
        if event.get("runSuccess") == true
          event.set("runStatus", "success")
        elsif event.get("runSuccess") == false
          event.set("runStatus", "failed")
        else
          event.set("runStatus", "unknown")
        end
        
        # Parse recipes changed if present
        recipes_changed = event.get("runRecipesChanged")
        if recipes_changed && recipes_changed != ""
          recipes_array = recipes_changed.split(";")
          event.set("recipesChangedCount", recipes_array.length)
          event.set("recipesChangedList", recipes_array)
        else
          event.set("recipesChangedCount", 0)
        end
      '
    }
    
    # Add metadata
    mutate {
      add_field => {
        "processed_at" => "%{@timestamp}"
        "data_type" => "run_metrics"
      }
      
      # Clean up temporary parsed fields
      remove_field => ["headers", "host", "@version"]
    }
  }
  
  # Data validation
  if ![runId] or ![developer] {
    mutate {
      add_tag => ["validation_error", "missing_required_fields"]
    }
  }
  
  if [runElapsedTimeMs] and [runElapsedTimeMs] > 1800000 {  # 30 minutes
    mutate {
      add_tag => ["slow_run"]
    }
  }
  
  if [recipesChangedCount] and [recipesChangedCount] > 0 {
    mutate {
      add_tag => ["has_changes"]
    }
  }
}

output {
  # Console output for debugging
  stdout {
    codec => rubydebug
  }

  # Store in Elasticsearch with proper index
  elasticsearch {
    hosts => ["elasticsearch:9200"]
    index => "run-metrics-%{+YYYY.MM.dd}"
    document_id => "%{runId}-%{[@timestamp]}"
  }
}