input {
  http {
    port => 8080
    codec => line
  }
}

filter {
  # Skip header line
  if [message] =~ /^origin,/ {
    drop { }
  }
  
  # Skip empty lines  
  if [message] =~ /^\s*$/ {
    drop { }
  }
  
  # Parse CSV
  csv {
    separator => ","
    columns => [
      "origin", "path", "branch", "developer", "runSuccess",
      "runStartTime", "runEndTime", "runId", "runChangeset",
      "runMavenVersion", "runGradleVersion", "runBazelVersion",
      "runDotnetVersion", "runPythonVersion", "runNodeVersion",
      "runRecipe", "runRecipesChanged",
      "runSourceFileCount", "runVisitedSourceFileCount",
      "runLineCount", "runVisitedLineCount",
      "runRecipeRunElapsedTimeMs", "runElapsedTimeMs", "organization"
    ]
  }
  
  # Only process valid records
  if [runId] {
    # Convert types
    mutate {
      convert => {
        "runSuccess" => "boolean"
        "runElapsedTimeMs" => "integer"
        "runRecipeRunElapsedTimeMs" => "integer"
        "runSourceFileCount" => "integer"
        "runVisitedSourceFileCount" => "integer"
        "runLineCount" => "integer"
        "runVisitedLineCount" => "integer"
      }
    }
    
    # Parse dates
    date {
      match => [ "runStartTime", "ISO8601" ]
      target => "runStartTimeParsed"
    }
    
    date {
      match => [ "runEndTime", "ISO8601" ]
      target => "runEndTimeParsed"
    }
    
    # Calculate metrics
    ruby {
      code => '
        # Calculate durations
        run_ms = event.get("runElapsedTimeMs")
        if run_ms
          event.set("runDurationSeconds", run_ms.to_f / 1000)
        end
        
        recipe_ms = event.get("runRecipeRunElapsedTimeMs")
        if recipe_ms
          event.set("recipeRunDurationSeconds", recipe_ms.to_f / 1000)
        end
        
        # Set run status
        success = event.get("runSuccess")
        if success == true
          event.set("runStatus", "success")
        elsif success == false
          event.set("runStatus", "failed")  
        else
          event.set("runStatus", "unknown")
        end
        
        # Calculate visitation percentages
        source_count = event.get("runSourceFileCount")
        visited_count = event.get("runVisitedSourceFileCount")
        if source_count && visited_count && source_count > 0
          event.set("fileVisitationPercentage", (visited_count.to_f / source_count.to_f) * 100)
        end
        
        line_count = event.get("runLineCount")
        visited_lines = event.get("runVisitedLineCount")
        if line_count && visited_lines && line_count > 0
          event.set("lineVisitationPercentage", (visited_lines.to_f / line_count.to_f) * 100)
        end
        
        # Determine build tool
        if event.get("runGradleVersion") && event.get("runGradleVersion") != ""
          event.set("primaryBuildTool", "Gradle")
        elsif event.get("runMavenVersion") && event.get("runMavenVersion") != ""
          event.set("primaryBuildTool", "Maven")
        else
          event.set("primaryBuildTool", "Unknown")
        end
        
        # Parse recipes changed
        recipes_changed = event.get("runRecipesChanged")
        if recipes_changed && recipes_changed != ""
          recipes_array = recipes_changed.split(";")
          event.set("recipesChangedCount", recipes_array.length)
          event.set("recipesChangedList", recipes_array)
        else
          event.set("recipesChangedCount", 0)
        end
        
        # Extract repository info
        path = event.get("path")
        if path
          parts = path.split("/")
          if parts.length >= 2
            event.set("repositoryOwner", parts[-2])
            event.set("repositoryName", parts[-1])
          end
        end
      '
    }
    
    # Clean up
    mutate {
      remove_field => ["message", "host", "@version"]
    }
  }
}

output {
  stdout { codec => rubydebug }
  
  if [runId] {
    elasticsearch {
      hosts => ["elasticsearch:9200"]
      index => "run-metrics-%{+YYYY.MM.dd}"
      document_id => "%{runId}"
    }
  }
}