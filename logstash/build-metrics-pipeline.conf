input {
  http {
    port => 8080
    codec => plain
    response_code => 200
    additional_codecs => {
      "application/json" => "json"
    }
  }
}

filter {
  # Handle CSV data from HTTP or file input
  if [headers][content-type] =~ /text\/csv/ or [headers][content-type] =~ /text\/plain/ {
    csv {
      separator => ","
      columns => [
        "origin",
        "path",
        "branch",
        "developer",
        "buildSuccess",
        "buildStartTime",
        "buildEndTime",
        "buildLog",
        "buildId",
        "buildChangeset",
        "buildDependencyResolutionTimeMs",
        "buildMavenVersion",
        "buildGradleVersion",
        "buildBazelVersion",
        "buildDotnetVersion",
        "buildPythonVersion",
        "buildNodeVersion",
        "buildSourceFileCount",
        "buildLineCount",
        "buildParseErrorCount",
        "buildWeight",
        "buildMaxWeight",
        "buildMaxWeightSourceFile",
        "buildElapsedTimeMs",
        "cloneSuccess",
        "cloneCloneUri",
        "cloneStartTime",
        "cloneEndTime",
        "cloneLog",
        "cloneChangeset",
        "cloneElapsedTimeMs",
        "organization"
      ]
      skip_header => true
      skip_empty_columns => true
    }
    
    # Convert data types
    mutate {
      convert => {
        "buildSuccess" => "boolean"
        "buildDependencyResolutionTimeMs" => "integer"
        "buildSourceFileCount" => "integer"
        "buildLineCount" => "integer"
        "buildParseErrorCount" => "integer"
        "buildWeight" => "integer"
        "buildMaxWeight" => "integer"
        "buildElapsedTimeMs" => "integer"
        "cloneSuccess" => "boolean"
        "cloneElapsedTimeMs" => "integer"
      }
    }
    
    # Parse timestamps
    date {
      match => [ "buildStartTime", "ISO8601" ]
      target => "buildStartTimeParsed"
    }
    
    date {
      match => [ "buildEndTime", "ISO8601" ]
      target => "buildEndTimeParsed"
    }
    
    date {
      match => [ "cloneStartTime", "ISO8601" ]
      target => "cloneStartTimeParsed"
    }
    
    date {
      match => [ "cloneEndTime", "ISO8601" ]
      target => "cloneEndTimeParsed"
    }
    
    # Calculate additional metrics and clean data
    ruby {
      code => '
        # Extract repository name from path
        path = event.get("path")
        if path
          repo_parts = path.split("/")
          if repo_parts.length >= 2
            event.set("repositoryOwner", repo_parts[-2])
            event.set("repositoryName", repo_parts[-1])
          end
        end
        
        # Calculate build duration in seconds
        build_ms = event.get("buildElapsedTimeMs")
        if build_ms
          event.set("buildDurationSeconds", build_ms.to_f / 1000)
        end
        
        # Calculate clone duration in seconds
        clone_ms = event.get("cloneElapsedTimeMs")
        if clone_ms
          event.set("cloneDurationSeconds", clone_ms.to_f / 1000)
        end
        
        # Determine primary build tool
        if event.get("buildGradleVersion")
          event.set("primaryBuildTool", "Gradle")
        elsif event.get("buildMavenVersion")
          event.set("primaryBuildTool", "Maven")
        elsif event.get("buildBazelVersion")
          event.set("primaryBuildTool", "Bazel")
        elsif event.get("buildNodeVersion")
          event.set("primaryBuildTool", "Node")
        elsif event.get("buildPythonVersion")
          event.set("primaryBuildTool", "Python")
        elsif event.get("buildDotnetVersion")
          event.set("primaryBuildTool", "Dotnet")
        end
        
        # Normalize organization (handle ε or empty)
        org = event.get("organization")
        if org == "ε" || org == "" || org.nil?
          event.set("organization", "Unknown")
        end
        
        # Set build status string
        if event.get("buildSuccess") == true
          event.set("buildStatus", "success")
        elsif event.get("buildSuccess") == false
          event.set("buildStatus", "failed")
        else
          event.set("buildStatus", "unknown")
        end
      '
    }
    
    # Add metadata
    mutate {
      add_field => {
        "processed_at" => "%{@timestamp}"
        "data_type" => "build_metrics"
      }
      
      # Clean up temporary parsed fields
      remove_field => ["headers", "host", "@version"]
    }
  }
  
  # Handle JSON payload with CSV data
  if [headers][content-type] =~ /application\/json/ {
    if [csv_data] {
      mutate {
        split => { "csv_data" => "\n" }
      }
      
      split {
        field => "csv_data"
      }
      
      csv {
        source => "csv_data"
        separator => ","
        columns => [
          "origin", "path", "branch", "developer", "buildSuccess",
          "buildStartTime", "buildEndTime", "buildLog", "buildId", "buildChangeset",
          "buildDependencyResolutionTimeMs", "buildMavenVersion", "buildGradleVersion",
          "buildBazelVersion", "buildDotnetVersion", "buildPythonVersion", "buildNodeVersion",
          "buildSourceFileCount", "buildLineCount", "buildParseErrorCount",
          "buildWeight", "buildMaxWeight", "buildMaxWeightSourceFile", "buildElapsedTimeMs",
          "cloneSuccess", "cloneCloneUri", "cloneStartTime", "cloneEndTime",
          "cloneLog", "cloneChangeset", "cloneElapsedTimeMs", "organization"
        ]
        skip_header => false
      }
      
      mutate {
        remove_field => ["csv_data"]
      }
    }
  }
  
  # Data validation
  if ![buildId] or ![developer] {
    mutate {
      add_tag => ["validation_error", "missing_required_fields"]
    }
  }
  
  if [buildParseErrorCount] and [buildParseErrorCount] > 0 {
    mutate {
      add_tag => ["has_parse_errors"]
    }
  }
  
  if [buildElapsedTimeMs] and [buildElapsedTimeMs] > 600000 {  # 10 minutes
    mutate {
      add_tag => ["slow_build"]
    }
  }
}

output {
  # Console output for debugging
  stdout {
    codec => rubydebug
  }

  # Store in Elasticsearch with proper index
  elasticsearch {
    hosts => ["localhost:9200"]
    index => "build-metrics-%{+YYYY.MM.dd}"
    document_id => "%{buildId}-%{[@timestamp]}"
  }

  # Send to monitoring API
  # http {
  #   url => "http://localhost:3000/api/build-metrics"
  #   http_method => "post"
  #   format => "json"
  # }
}